#pragma once

/*
	Катков Антон. 2017 год. 

	skype : nestaby
*/

#include "Object.h"
#include "Consts.h"
#include <stdlib.h>
#include <vector>

/*
	Вектор будет хранить список из векторов. Каждый внутренний вектор может хранить только 2 элемента - x , y. 
	Будет использоваться для сохранения пути от головы змейки до ближайшей еды.
*/
typedef std::vector<std::vector<int>> PointsToFood;

class Snake;

/*
	GameBoard - игровое поле определенного, заданного размера, матрица.

	Поле хранит в себе объекты - стены, еда, змея. 

	Автоматическая генерация поля, создание еды и запуск змеи, которая автоматически ищет путь
	до ближайшей еды при помощи волнового алгоритма.
*/

namespace SnakeGame 
{
	class GameBoard
	{
	private:
		/*
			Игровое поле. 

			Поле будет в себе хранить реальные объекты. Если клетка хранит nullptr - значит в ней ничего нет.
			Если там конкретный Object, значит это или Wall или Snake или Food. Все эти классны унаследованы от Object.
		*/
		Object * _gameMatrix[GAME_BOARD_WIDTH][GAME_BOARD_HEIGHT];

		/*
			Перед каждым ходом змейки сохраняем предыдущее состояние поля для того, чтобы без лишних затрах обновить
			только те участки поля, которые обновились. Нужно, чтобы консоль не моргала при обновлении данных.
		*/
		char _gameMatrixPrevStep[GAME_BOARD_WIDTH][GAME_BOARD_HEIGHT];

	public:
		GameBoard();

	// работа с элементами на поле, первая инициализация, создание стен, еды, головы змеи и т.д
	private:
		void CreateGameBoard();											// первое создание игрового поля
		void CleanGameBoard();											// очистка игрового поля
		void InitializeGameBoard();										// инициализация игрового поля (создается еда, змейка, стены)
		void CreateWallsAroundPerimeter();								// создать стены по периметру
		void CreateFoodsAroundPerimeter();								// заспавнить еду на игровом поле
		void CreateFoodOnRandomPosition();												// создает одну еду если это возможно
		void CopyMatrixDataToTempMatrix();

	// работа с объектами на поле, создание, удаление, разные проверки
	private:
		Object * CreateObject(ObjectType);								// создает и возвращает объект по переданному типу
		Object * FindGameObject(int x, int y);							// находит и возвращает объект из матрицы по координатам
		bool IsPositionCorrect(int x, int y);							// проверка, входят ли переданные координаты в переделы матрицы. false если < 0 или > размера поля
		void CleanObjectFromMatrix(Object *, int x, int y);				// удаляет элемент из матрицы и очищает объект из памяти. Передается сам объект и его координаты в матрице.
		int GetNumberFreeCells();

	// работа со змейкой
	private:
		void CreateSnakeHead(int x, int y);								// создается голова для змеи по заданным координатам
		void CreateSnakeHead();											// создается голова для змеи в рандомных координатах
		Snake * FindHeadSnake();										// находит и возвращает голову змеи в матрице. Если ее нет, возвращает nullptr
		bool IsInteraction(int x, int y, ObjectType &);					// пересечется ли голова змеи с чем-то по координатам, возвращает true если пересечется и запишет по ссылке тип пересечения
		bool AttemptMoveOrEat(int x, int y);							// проверка на пересечение с едой, если пересеклись, создается новая голова, если нет, то перемещаем змейку в пустую клетку
		bool EatFoodAndCreatePart(int x, int y);						// съесть еду и добавить кусочек к змее
		void AddSnakePart(int x, int y);								// добавить к змее кусочек. вызывается если змея ест одну еду.
		void MoveSnakeTo(int x, int y);									// переместить змею в заданные координаты
		bool IsPositionsNear(int cX, int cY, int nX, int nY);			// проверяет, рядом ли координаты. например, проврка нужна для перемещения головы змейки. голова змейки может перемещаться только на 1 клетку
		void FindAndMakeNextSteps();									// внутри находим пути до ближайшей еды. рассчитываем следующую позицию для змейки, увеличиваем ее если надо. перемещаем и т.д.
		Snake * FindLastPart();											// поиск последнего элемента змейки. Если последнего нет, то последний будет головой.
		int GetSnakeSize();

	// поиск координат до ближайшей еды
	private:
		PointsToFood SearchPathToNearestFood();							// для поиска используется волновой алгоритм поиска пути.

	// работа с объектом этого класса
	public:
		void MakeMovement();											// каждый ход вызываем функцию (в цикле из мейна), делаем ход
		bool IsExit();													// выход из игры для основного цикла. Пока не потребовалось.

	// работа с консолью
	private:
		void PrintGameBoardToConsole();									// после каждого хода змейки отрисоываем данные в консоли. Отрисовываем только те данные, которые были обновлены, чтобы не нагружать консоль и ничего не моргало.
		void ClearGameBoardConsole();
	};

}